WordNet is a graph.
It is potentially invaluable resource for injecting knowledge into applications.

WordNet consists of enough data to exceed the recommended capacity of Java Collections 
(e.g., SortedMap<String, X>), but not enough to justify a full relational database.

WordNet is probably the single most used NLP resource.
It embodies one of the most fundamental of all NLP problems: "word sense disambiguation".
XXX

There are a lot of interfaces to WordNet.
XXX list them and their license and URL

Why Yawni ?
- commercial-grade implementation
  - small memory foot print
  - efficient algorithms
  - simple, intuitive, and well documented API
  - easy Maven build with minimal dependencies
  - extensive unit tests
- includes refined GUI browser featuring
  - user friendly, snappy
  - incremental find
  - good keyboard support
  - cross-platform including zero-install version
- commercial-friendly Apache license
newvisionhomeremodeling
Changes in 2.x versions

- Extreme speed improvements: literally faster than the C version (benchmark source included)
  - FileManager.CharStream and FileManager.NIOCharStream
  - XXX copious amounts of caching (bounded, LRU strategy)
  - re-implemented LRUCache in terms of LinkedHashMap (much more efficient)
  - reduced garbage generated by various operations
- Major reduction in memory requirements
  - use of primitives where possible (hidden by API)
  - elimination of unused or unneeded fields
- Implemented Morphy stemming algorithms
- Completely rewritten GUI browser in Java Swing featuring
  - Incremental find
  - No limits on search (Never see "Search too large.  Narrow search and try again..." again)
- Support for WordNet 3.0 data files (and all older formats)
- Supports reading data files from JAR file
- Many bug fixes
  - fixed broken PointerType's
  - fixed Verb example sentences and generic frames (and made them directly accessible)
  - iteration bugs and memory leaks
  - various thread safety bugs
- Updated to leverage Java 1.5
  - generics
  - use of Enum, EnumSet, and EnumMap where apropos
  - re-implemented LRUCache in terms of LinkedHashMap (much more efficient)
  - uses maximally configurable slf4j logging system
  - added LookaheadIterator (analagous to old LookaheadEnumeration)
- New / changed API methods
  - renamed Word -> WordSense, IndexWord -> Word, Pointer -> Relation, PointerType -> RelationType, PointerTarget -> RelationTarget
    - easier to understand, matches W3C proposal (http://www.w3.org/TR/wordnet-rdf/)
  - WordSense.getSenseNumber()
  - WordSense.getTaggedSenseCount()
  - WordSense.getAdjPosition()
  - WordSense.getVerbFrames()
  - Word.isCollocation()
  - Word.getPointerTypes()
  - Synset.getLexCategory()
  - added RelationTarget.getSynset()
  - Word.getSenses() -> Word.getSynsets() and added List<WordSense> Word.getSenses()
  - DictionaryDatabase iteration methods are Iterables for ease of use (e.g., for loops)
  - all core classes implement Comparable<T>
  - all core classes implement Iterable<WordSense>
  - added iteration for all WordSenses and all Pointers (and all of certain PointerType)
  - added support for POS.ALL where apropos
  - all major classes are final
  - currently, no major classes are Serializable
  - removed RMI client / server capabities - deemed overkill 
  - removed applet - didn't justify its maintenance burden
- Growing suite of unit tests
- Automated all build infrastructure using Apache Maven

